/**
 * game-embed.js - AUTO-GENERATED FILE
 * 
 * DO NOT EDIT THIS FILE DIRECTLY!
 * 
 * This file is automatically generated by build-embed.ps1
 * To make changes, edit the source files and rebuild:
 *   - game/sprites.js (sprite data)
 *   - game/game.js (game logic)
 *   - game/game-embed-template.js (wrapper/overlay)
 * 
 * Then run: cd game && .\build-embed.ps1
 */
/**
 * Motorcycle Runner - Embeddable Game
 * 
 * Usage: <script src="https://kurtzeborn.net/game/game-embed.js"></script>
 * 
 * Controls:
 * - Press SPACEBAR to toggle game overlay
 * - Press ESC to close game
 * - Game controls: SPACE/â†‘ to jump, â†“ to duck
 * - Mobile: Tap top half to jump, hold bottom half to duck
 */

(function() {
    'use strict';
    
    // Prevent multiple instances
    if (window.MotorcycleRunner) {
        console.warn('Motorcycle Runner already loaded');
        return;
    }
    
    let gameOverlay = null;
    let isGameVisible = false;
    let gameLoopId = null; // Track animation frame for cleanup
    
    // Create and inject game overlay
    function createGameOverlay() {
        const overlay = document.createElement('div');
        overlay.id = 'motorcycle-runner-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 999999;
            display: none;
            justify-content: center;
            align-items: center;
        `;
        
        // Load game content dynamically
        overlay.innerHTML = `
            <style>
                #motorcycle-runner-container {
                    position: relative;
                    max-width: 100%;
                    max-height: 100%;
                }
                
                #motorcycle-runner-canvas {
                    border: 4px solid black;
                    background: linear-gradient(to bottom, #87ceeb 0%, #e0f6ff 50%, #c2b280 50%, #c2b280 100%);
                    display: block;
                    max-width: 100vw;
                    max-height: 100vh;
                    touch-action: none;
                }
                
                .motorcycle-game-overlay {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center;
                    background: rgba(0, 0, 0, 0.85);
                    padding: 30px 50px;
                    border: 4px solid lightgreen;
                    border-radius: 10px;
                    color: lightgreen;
                    display: none;
                    font-family: 'Courier New', monospace;
                }
                
                .motorcycle-game-overlay h2 {
                    margin: 0 0 20px 0;
                    font-size: 48px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                }
                
                .motorcycle-game-overlay p {
                    margin: 10px 0;
                    font-size: 24px;
                }
                
                .motorcycle-game-overlay button {
                    margin-top: 20px;
                    padding: 15px 30px;
                    font-size: 20px;
                    background: lightgreen;
                    color: black;
                    border: 2px solid black;
                    cursor: pointer;
                    font-weight: bold;
                    font-family: 'Courier New', monospace;
                }
                
                .motorcycle-game-overlay button:hover {
                    background: rgba(210, 255, 0, 0.9);
                    transform: scale(1.05);
                }
                
                .motorcycle-instructions {
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    color: lightgreen;
                    background: rgba(0, 0, 0, 0.7);
                    padding: 15px;
                    border: 2px solid lightgreen;
                    border-radius: 5px;
                    font-size: 14px;
                    font-family: 'Courier New', monospace;
                }
                
                .motorcycle-instructions h3 {
                    margin: 0 0 10px 0;
                    font-size: 18px;
                }
                
                .motorcycle-instructions p {
                    margin: 5px 0;
                }
                
                .motorcycle-close-button {
                    position: absolute;
                    top: 20px;
                    left: 20px;
                    background: rgba(255, 0, 0, 0.7);
                    color: white;
                    border: 2px solid white;
                    padding: 10px 20px;
                    font-size: 16px;
                    cursor: pointer;
                    font-weight: bold;
                    border-radius: 5px;
                    font-family: 'Courier New', monospace;
                }
                
                .motorcycle-close-button:hover {
                    background: rgba(255, 0, 0, 0.9);
                }
            </style>
            
            <div id="motorcycle-runner-container">
                <button class="motorcycle-close-button" id="motorcycle-close-btn">âœ• Close (ESC)</button>
                
                <div class="motorcycle-instructions" id="motorcycle-instructions">
                    <h3>Controls</h3>
                    <p><strong>Desktop:</strong></p>
                    <p>SPACE or â†‘ - Jump</p>
                    <p>â†“ - Duck</p>
                    <p><strong>Mobile:</strong></p>
                    <p>Tap Top Half - Jump</p>
                    <p>Hold Bottom Half - Duck</p>
                </div>
                
                <canvas id="motorcycle-runner-canvas" width="1000" height="400"></canvas>
                
                <div id="motorcycle-game-overlay" class="motorcycle-game-overlay">
                    <h2>GAME OVER</h2>
                    <p id="motorcycle-final-score">Score: 0</p>
                    <p id="motorcycle-daily-high-score">Best Today: 0</p>
                    <p id="motorcycle-all-time-high-score">Best Ever: 0</p>
                    <button id="motorcycle-restart-btn">RESTART</button>
                </div>
                
                <div id="motorcycle-orientation-overlay" class="motorcycle-game-overlay" style="display: none;">
                    <h2>ðŸ“± ROTATE DEVICE</h2>
                    <p>Please rotate your device to landscape mode to play</p>
                </div>
            </div>
        `;
        
        document.body.appendChild(overlay);
        return overlay;
    }
    
    function showGame() {
        if (!gameOverlay) {
            gameOverlay = createGameOverlay();
            // Initialize game after DOM is ready
            setTimeout(initializeGame, 0);
        }
        gameOverlay.style.display = 'flex';
        isGameVisible = true;
    }
    
    function hideGame() {
        if (gameOverlay) {
            gameOverlay.style.display = 'none';
            isGameVisible = false;
            // Stop the game loop to save resources
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
        }
    }
    
    // Global keyboard handler for toggling game
    document.addEventListener('keydown', function(e) {
        // Spacebar to toggle (only when game is hidden)
        if (e.code === 'Space' && !isGameVisible) {
            e.preventDefault();
            showGame();
            return;
        }
        
        // ESC to close game
        if (e.code === 'Escape' && isGameVisible) {
            e.preventDefault();
            hideGame();
            return;
        }
    });
    
    // Initialize game (called after overlay is created)
    function initializeGame() {
        // Close button handler
        const closeBtn = document.getElementById('motorcycle-close-btn');
        
        closeBtn.addEventListener('click', hideGame);
        
        // Listen for game events to manage close button visibility
        window.addEventListener('motorcyclegamestart', () => {
            closeBtn.style.display = 'none';
        });
        
        window.addEventListener('motorcyclegameover', () => {
            closeBtn.style.display = 'block';
        });
        
        // Embed sprites.js and game.js content inline
        (function() {
            // Motorcycle Runner - Sprite Definitions
// Pixel art sprites defined as 2D arrays with indexed colors

// Color constants - single source of truth for all game colors
const COLORS = {
    TRANSPARENT: null,
    WHEEL: '#6a6a6a',
    BODY: '#333333',
    RIDER: '#999999',
    HELMET: '#ff0000',
    BIRD_BODY: '#654321',
    BIRD_WING: '#8b6914',
    VEHICLE_BODY: '#cc0000',
    VEHICLE_DETAIL: '#990000',
    VEHICLE_WINDOW: '#6688EB',
    GROUND_LINE: '#2d2d2d',
    CENTER_LINE: '#ffffff',
    TEXT: '#2d2d2d'
};

// Vehicle color palettes for randomization
const VEHICLE_COLORS = [
    { body: '#cc0000', detail: '#990000' }, // Red
    { body: '#e8e8e8', detail: '#c0c0c0' }, // White/Light Gray
    { body: '#8B4513', detail: '#654321' }, // Brown
    { body: '#4169E1', detail: '#1E3A8A' }  // Blue
];

// Track last vehicle color to avoid repetition
let lastVehicleColorIndex = -1;

// Function to get random vehicle colors (avoids repeating the same color)
function getRandomVehicleColors() {
    let colorIndex;
    // If we have more than one color option, avoid repeating the last one
    if (VEHICLE_COLORS.length > 1) {
        do {
            colorIndex = Math.floor(Math.random() * VEHICLE_COLORS.length);
        } while (colorIndex === lastVehicleColorIndex);
    } else {
        colorIndex = 0;
    }
    lastVehicleColorIndex = colorIndex;
    return VEHICLE_COLORS[colorIndex];
}

// Function to create sprite palette with vehicle colors
function createSpritePalette(vehicleColors = { body: COLORS.VEHICLE_BODY, detail: COLORS.VEHICLE_DETAIL }) {
    return [
        COLORS.TRANSPARENT,      // 0 - transparent
        COLORS.WHEEL,            // 1 - wheels
        COLORS.BODY,             // 2 - motorcycle body
        vehicleColors.body,      // 3 - vehicle body (randomized)
        COLORS.RIDER,            // 4 - rider body/gray
        COLORS.HELMET,           // 5 - helmet red
        COLORS.BIRD_BODY,        // 6 - bird body brown
        COLORS.BIRD_WING,        // 7 - bird wings
        vehicleColors.detail,    // 8 - vehicle details (randomized)
        COLORS.VEHICLE_WINDOW    // 9 - vehicle windows (light blue)
    ];
}

// Default sprite palette
let SPRITE_PALETTE = createSpritePalette();

// Pixel Art Sprites
const SPRITES = {
    // Motorcycle normal stance (20x16 pixels)
    MOTORCYCLE_NORMAL: [
        [0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,5,5,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,5,5,5,2,2,0,0,0,0,0,0,0,0,0,0,0],
        [2,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
        [2,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,2,0,0,0,4,4,4,4,4,4,2,0,0,0,0,0,0,0,0],
        [0,2,0,0,0,4,4,4,0,0,0,0,2,0,0,0,0,0,0,0],
        [0,0,2,2,2,4,4,4,4,0,0,0,0,2,0,0,0,0,0,0],
        [0,2,2,2,2,4,4,4,4,4,2,2,2,2,1,0,0,0,0,0],
        [5,2,2,2,2,2,2,2,4,4,4,2,2,2,2,0,0,0,0,0],
        [0,1,1,2,2,2,2,2,2,4,4,2,2,2,2,2,1,1,1,0],
        [1,1,2,2,1,2,2,2,2,4,4,4,2,0,0,1,2,1,1,1],
        [1,1,2,1,1,0,0,0,0,0,2,2,0,0,0,1,1,2,1,1],
        [1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],
        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0]
    ],

    // Motorcycle ducking (20x12 pixels)
    MOTORCYCLE_DUCK: [
        [0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,5,5,2,2,2,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,5,5,5,2,2,0,0,0,0,0,0,0,0,0,0],
        [2,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
        [0,2,0,0,0,0,4,4,4,4,4,2,0,0,0,0,0,0,0,0],
        [0,0,2,2,2,4,4,4,4,0,0,0,0,2,0,0,0,0,0,0],
        [0,2,2,2,2,4,4,4,4,4,2,2,2,2,1,0,0,0,0,0],
        [5,2,2,2,2,2,2,2,4,4,4,2,2,2,2,0,0,0,0,0],
        [0,1,1,2,2,2,2,2,2,4,4,2,2,2,2,2,1,1,1,0],
        [1,1,2,2,1,2,2,2,2,4,4,4,2,0,0,1,2,1,1,1],
        [1,1,2,1,1,0,0,0,0,0,2,2,0,0,0,1,1,2,1,1],
        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0]
    ],
    
    // Vehicle sprites (obstacles)
    CAR: [
        [0,0,0,0,0,0,8,8,8,8,8,0,0,0,0,0],
        [0,0,0,8,8,8,3,3,3,3,3,8,8,0,0,0],
        [0,0,0,9,3,9,9,3,9,9,9,3,9,0,0,0],
        [0,0,0,9,3,9,9,3,9,9,9,3,3,9,0,0],
        [0,0,9,3,9,9,9,3,9,9,9,9,3,3,9,0],
        [0,0,9,3,9,9,9,3,9,9,9,9,9,3,3,3],
        [3,3,3,3,3,3,3,8,3,3,3,3,3,3,3,3],
        [3,3,3,3,3,3,3,8,3,3,3,3,3,3,3,3],
        [0,1,1,1,3,3,3,8,3,3,3,1,1,1,0,0],
        [1,1,1,1,1,8,8,8,8,8,1,1,1,1,1,0],
        [1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0],
        [0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0]
    ],

    TRUCK: [
        [0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,8,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,9,3,9,9,9,9,3,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,9,3,9,9,9,9,3,0,0,0,0,0,0,0,0,0],
        [0,0,0,9,3,9,9,9,9,9,3,0,0,0,0,0,0,0,0,0],
        [0,0,0,9,3,9,9,9,9,9,3,8,8,8,8,8,8,8,8,0],
        [0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8],
        [3,3,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],
        [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8],
        [0,1,1,1,1,3,3,3,3,3,3,3,3,3,3,1,1,1,1,8],
        [1,1,1,1,1,1,8,8,8,8,8,8,8,8,1,1,1,1,1,1],
        [1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1],
        [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],
    ],
    // 1 - tire, 3 - vehicle body, 8 - vehicle detail, 9 - vehicle window

    VAN: [
        [0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0],
        [0,0,0,0,8,8,3,3,3,3,3,3,3,3,3,3,8,3,3,3,8,0],
        [0,0,0,9,3,9,9,9,3,3,3,3,3,3,3,8,3,9,9,3,3,8],
        [0,0,0,9,3,9,9,9,3,3,3,3,3,3,8,3,9,9,9,9,3,3],
        [0,0,9,3,9,9,9,9,3,3,3,3,3,8,3,3,9,9,9,9,3,3],
        [0,0,9,3,9,9,9,9,3,3,3,3,8,3,3,3,3,9,9,3,3,3],
        [3,3,3,3,3,3,3,3,3,3,3,8,3,3,3,3,3,3,3,3,3,3],
        [8,8,8,8,8,8,8,8,8,8,8,3,3,3,3,3,3,3,3,3,3,3],
        [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [0,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,0],
        [1,1,1,1,1,1,8,8,8,8,8,8,8,8,8,8,1,1,1,1,1,1],
        [1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1],
        [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0]
    ],

    BUS: [
        [0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0],
        [0,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8],
        [9,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3],
        [9,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3],
        [9,9,9,9,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3],
        [9,9,9,9,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3,9,9,9,3,3],
        [9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [9,9,9,3,3,8,8,8,8,8,3,3,3,3,3,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],
        [9,9,3,3,3,8,9,8,9,8,3,3,3,3,8,3,3,3,3,3,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [9,9,3,3,3,8,9,8,9,8,3,3,3,8,3,3,3,3,3,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [3,3,3,3,3,8,3,8,3,8,3,3,8,3,3,3,3,3,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [3,1,1,1,1,8,3,8,3,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3,3,3,3,1,1,1,1,3,3,3,1,1,1,1,3],
        [1,1,8,8,1,1,3,8,3,8,3,3,3,3,3,3,3,3,8,3,3,3,3,8,3,3,3,1,1,8,8,1,1,3,1,1,8,8,1,1],
        [1,1,8,8,1,1,3,8,3,8,3,3,3,3,3,3,3,3,3,8,3,3,3,3,8,3,3,1,1,8,8,1,1,3,1,1,8,8,1,1],
        [1,1,1,1,1,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,1,1,8,1,1,1,1,1,1],
        [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0]
    ],

    SEMI_TRUCK: [
        [0,0,0,8,8,8,8,8,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0],
        [0,0,8,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [0,9,3,9,9,9,3,3,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [0,9,3,9,9,9,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [0,9,3,9,9,9,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [0,9,3,9,9,9,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [9,3,9,9,9,9,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3],
        [9,3,9,9,9,9,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [3,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [8,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [8,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [8,3,3,3,3,3,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
        [3,1,1,1,1,3,3,3,3,0,0,0,0,0,0,1,1,1,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,8,8,8,0],
        [1,1,1,1,1,1,3,3,3,3,3,3,3,3,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0],
        [1,1,8,8,1,1,3,3,3,3,3,3,3,3,1,1,8,8,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,8,8,1,1,0,0,0],
        [1,1,1,1,1,1,8,8,8,8,8,8,8,8,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0],
        [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
    ],

    // Bird/Bat with wings up
    BIRD_UP: [
        [0,0,0,0,0,0,0,6,0,0,0,0],
        [0,0,0,0,6,6,6,6,0,0,0,0],
        [0,0,6,6,6,6,6,0,0,0,0,0],
        [7,7,6,6,6,7,7,7,7,7,7,0],
        [0,7,7,7,7,7,7,7,0,0,0,0],
        [0,0,0,0,7,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    
    // Bird/Bat with wings down
    BIRD_DOWN: [
        [0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0],
        [0,7,7,7,7,7,7,7,0,0,0,0],
        [7,7,6,6,6,7,7,7,7,7,7,0],
        [0,0,6,6,6,6,6,7,0,0,0,0],
        [0,0,0,0,6,6,6,6,0,0,0,0],
        [0,0,0,0,0,0,0,6,0,0,0,0]
    ],
    
    // Billboard structure (text drawn separately) - 60x40 pixels
    BILLBOARD: [
        [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
        [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ],
};

            
            // Motorcycle Runner Game - Chrome T-Rex Style
// CODE REVIEW: Always increment version number before making changes

const VERSION = 'v0.16';

const canvas = document.getElementById('motorcycle-runner-canvas');
const ctx = canvas.getContext('2d');
const gameOverlay = document.getElementById('motorcycle-game-overlay');
const finalScoreEl = document.getElementById('motorcycle-final-score');
const dailyHighScoreEl = document.getElementById('motorcycle-daily-high-score');
const allTimeHighScoreEl = document.getElementById('motorcycle-all-time-high-score');
const restartBtn = document.getElementById('motorcycle-restart-btn');
const orientationOverlay = document.getElementById('motorcycle-orientation-overlay');
const instructionsEl = document.getElementById('motorcycle-instructions');

// Game configuration constants
const CONFIG = {
    // === GAME SPEED & DIFFICULTY ===
    INITIAL_SPEED: 6,
    SPEED_INCREMENT: 0.5,
    SPEED_INCREASE_INTERVAL: 300,
    
    // === SCORING ===
    SURVIVAL_POINTS_INTERVAL: 5, // Award 1 point every N frames
    VEHICLE_POINTS: 50,
    RIDEABLE_VEHICLE_POINTS: 100,
    FLYING_OBSTACLE_POINTS: 75,
    RIDEABLE_VEHICLE_MIN_SCORE: 300,
    FLYING_OBSTACLE_MIN_SCORE: 100,
    
    // === OBSTACLE SPAWNING - GROUND VEHICLES ===
    OBSTACLE_MIN_INTERVAL: 60,
    OBSTACLE_MAX_INTERVAL: 120,
    OBSTACLE_INTERVAL_DECREASE_RATE: 0.5,
    OBSTACLE_MIN_INTERVAL_CAP: 40,
    GROUND_INTERVAL_MIN_SPACING: 30,
    OBSTACLE_RETRY_DELAY: 20,
    
    // === OBSTACLE SPAWNING - FLYING (BIRDS) ===
    FLYING_OBSTACLE_MIN_INTERVAL: 100,
    FLYING_OBSTACLE_MAX_INTERVAL: 200,
    FLYING_OBSTACLE_SPEED_MULTIPLIER: 1.2,
    FLYING_INTERVAL_MIN_CAP: 60,
    FLYING_INTERVAL_MIN_SPACING: 50,
    BIRD_WING_FLAP_FRAME_INTERVAL: 10,
    SAFE_DISTANCE_BIRD_VEHICLE: 300,
    
    // === PLAYER PHYSICS ===
    FAST_FALL_GRAVITY: 2.5, // Extra gravity when ducking mid-air
    HITBOX_SIZE_RATIO: 0.7,
    
    // === VISUAL EFFECTS ===
    SPRITE_SCALE: 3,
    PARTICLE_SPAWN_INTERVAL: 5,
    COLLISION_FLASH_DURATION: 10,
    
    // === GROUND RENDERING ===
    GROUND_ROAD_WIDTH: 40,
    GROUND_DASH_SPACING: 40,
    GROUND_DASH_LENGTH: 20,
    CENTER_LINE_WIDTH: 3,
    
    // === SKY & DAY/NIGHT CYCLE ===
    SKY_DAY_COLOR: '#87CEEB',
    SKY_NIGHT_COLOR: '#1a1a2e',
    SKY_TRANSITION_SPEED: 0.01,
    SUN_Y_POSITION: 60,
    SUN_RADIUS: 30,
    SUN_MOON_SPEED: 0.5,
    SUN_START_X: 100,
    MOON_CRESCENT_OFFSET: 12,
    STAR_COUNT: 50,
    STAR_MIN_SIZE: 0.5,
    STAR_MAX_SIZE: 2.0,
    STAR_MIN_SPEED: 0.05,
    STAR_MAX_SPEED: 0.15,
    STAR_MIN_OPACITY: 0.5,
    STAR_MAX_OPACITY: 1.0,
    
    // === DEBUG ===
    DEBUG_MODE: false // Set to true to see hitboxes
};

// Note: COLORS and SPRITE_PALETTE are defined in sprites.js

// Sprite cache for performance
const spriteCache = new Map();

function getCachedSprite(sprite, scale = CONFIG.SPRITE_SCALE, flipH = false, palette = null) {
    // Use custom palette if provided, otherwise use default
    const usePalette = palette || SPRITE_PALETTE;
    
    // Create unique cache key including flip state and palette hash
    const paletteKey = palette ? palette[3] + palette[8] : 'default';
    const key = sprite + '_' + scale + '_' + (flipH ? 'f' : 'n') + '_' + paletteKey;
    
    if (!spriteCache.has(key)) {
        // Create offscreen canvas for this sprite
        const width = sprite[0].length * scale;
        const height = sprite.length * scale;
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = width;
        offscreenCanvas.height = height;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        
        // Apply horizontal flip if needed
        if (flipH) {
            offscreenCtx.translate(width, 0);
            offscreenCtx.scale(-1, 1);
        }
        
        // Draw sprite once to offscreen canvas
        for (let row = 0; row < sprite.length; row++) {
            for (let col = 0; col < sprite[row].length; col++) {
                const colorIndex = sprite[row][col];
                if (colorIndex !== 0) {
                    offscreenCtx.fillStyle = usePalette[colorIndex];
                    offscreenCtx.fillRect(
                        col * scale,
                        row * scale,
                        scale,
                        scale
                    );
                }
            }
        }
        
        spriteCache.set(key, offscreenCanvas);
    }
    
    return spriteCache.get(key);
}

// Sprite rendering function - now uses cached sprites
function drawSprite(sprite, x, y, scale = CONFIG.SPRITE_SCALE, flipH = false, palette = null) {
    const cachedSprite = getCachedSprite(sprite, scale, flipH, palette);
    ctx.drawImage(cachedSprite, Math.floor(x), Math.floor(y));
}

// Get sprite dimensions after scaling
function getSpriteDimensions(sprite, scale = CONFIG.SPRITE_SCALE) {
    return {
        width: sprite[0].length * scale,
        height: sprite.length * scale
    };
}

// Game state constants
const GAME_STATES = {
    WAITING: 'waiting',
    PLAYING: 'playing',
    GAME_OVER: 'gameOver'
};

// Game state
let gameState = GAME_STATES.WAITING;
let score = 0;
// CODE REVIEW: Always parseInt() localStorage values (they're strings)
let highScore = parseInt(localStorage.getItem('motorcycleHighScore')) || 0;
let dailyHighScore = 0;
let allTimeHighScore = parseInt(localStorage.getItem('motorcycleAllTimeHighScore')) || 0;

// Load daily high score (reset if it's a new day)
function loadDailyHighScore() {
    const today = new Date().toDateString();
    const lastPlayDate = localStorage.getItem('motorcycleLastPlayDate');
    
    if (lastPlayDate === today) {
        dailyHighScore = parseInt(localStorage.getItem('motorcycleDailyHighScore')) || 0;
    } else {
        // New day, reset daily high score
        dailyHighScore = 0;
        localStorage.setItem('motorcycleLastPlayDate', today);
        localStorage.setItem('motorcycleDailyHighScore', '0');
    }
}

loadDailyHighScore();
let frameCount = 0;
let gameSpeed = CONFIG.INITIAL_SPEED;
let collisionFlash = 0;
let landingAnimation = 0;
let nextGroundObstacleFrame = 0;
let nextFlyingObstacleFrame = 0;
let groundObstacleInterval = CONFIG.OBSTACLE_MAX_INTERVAL;
let flyingObstacleInterval = CONFIG.FLYING_OBSTACLE_MAX_INTERVAL;
let lastConvoyEndX = -1000; // Track the end position of the last convoy
let nextBillboardFrame = 600; // First billboard at 10 seconds (600 frames at 60 FPS)

// Billboard messages
const BILLBOARD_MESSAGES = [
    ['Eastside', 'Harley'],
    ['Emerald City', 'Harley'],
    ['Harley', 'Davidson', 'Motorcycles'],
    ['Life is', 'short, roads', 'are long.'],
    ['Two wheels,', 'One love', '#BikerLife'],
    ['YOU GOT', 'THIS!'],
    ['Eat.  Sleep.', 'Ride.', 'Repeat.'],
    ['NICE', 'MOVES!'],
    ['LEGENDARY!'],
    ['STAY', 'FOCUSED!'],
    ['KEEP', 'GOING!'],
    ['RIDE ON!'],
    ['SKILLED', 'RIDER!'],
    ['TOO FAST!'],
    ['BEAST', 'MODE!'],
    ['DANGER', 'ZONE!']
];

// Motorcycle object
const motorcycle = {
    x: 50,
    y: canvas.height - 140,
    velocityY: 0,
    gravity: 0.8,
    jumpPower: -15,
    isJumping: false,
    isDucking: false,
    groundY: canvas.height - 140,
    duckHeight: 40,
    normalHeight: 60,
    isRidingVehicle: false,
    ridingVehicle: null
};

// Obstacles array
let obstacles = [];
// Define obstacle types - dimensions are calculated from sprites automatically
function getObstacleTypes() {
    return [
        { sprite: 'CAR', ...getSpriteDimensions(SPRITES.CAR), type: 'vehicle', rideable: false },
        { sprite: 'TRUCK', ...getSpriteDimensions(SPRITES.TRUCK), type: 'vehicle', rideable: false },
        { sprite: 'VAN', ...getSpriteDimensions(SPRITES.VAN), type: 'vehicle', rideable: false },
        { sprite: 'BUS', ...getSpriteDimensions(SPRITES.BUS), type: 'vehicle', rideable: true },
        { sprite: 'SEMI_TRUCK', ...getSpriteDimensions(SPRITES.SEMI_TRUCK), type: 'vehicle', rideable: true }
    ];
}
const obstacleTypes = getObstacleTypes();

// Flying obstacles
let flyingObstacles = [];
const flyingObstacleConfig = {
    ...getSpriteDimensions(SPRITES.BIRD_UP),
    heightVariations: [-140, -120, -100, -60, -40] // Mix of high (jump over) and low (duck under) birds
};

// Billboards
let billboards = [];

// Ground line
const groundY = canvas.height - 80;

// Sun/moon position (crosses sky as game progresses)
let sunX = 100;
let isNightMode = false;
let skyTransition = 0; // 0 = day, 1 = night, crossfades between

// Sky color constants for easy reference
const SKY_COLORS = {
    DAY: CONFIG.SKY_DAY_COLOR,
    NIGHT: CONFIG.SKY_NIGHT_COLOR,
    TEXT_DAY: '#2d2d2d',
    TEXT_NIGHT: '#ffffff',
    SUN_CORE: '#FFD700',
    SUN_GLOW: [
        'rgba(255, 255, 150, 0.8)',
        'rgba(255, 220, 100, 0.4)',
        'rgba(255, 200, 80, 0.2)',
        'rgba(255, 180, 60, 0)'
    ],
    MOON: '#F0E68C',
    STAR: 'rgba(255, 255, 255, {opacity})'
};

// Stars for night mode
let stars = [];

// Particle system for visual effects
let particles = [];

// Interpolate between two hex colors
function interpolateColor(color1, color2, factor) {
    const c1 = parseInt(color1.slice(1), 16);
    const c2 = parseInt(color2.slice(1), 16);
    const r1 = (c1 >> 16) & 0xff;
    const g1 = (c1 >> 8) & 0xff;
    const b1 = c1 & 0xff;
    const r2 = (c2 >> 16) & 0xff;
    const g2 = (c2 >> 8) & 0xff;
    const b2 = c2 & 0xff;
    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);
    return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
}

class Particle {
    constructor(x, y, vx, vy, color, life) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = life;
        this.maxLife = life;
        this.size = 2;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1; // gravity
        this.life--;
        return this.life > 0;
    }
    
    draw() {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

function spawnDustParticle() {
    if (frameCount % CONFIG.PARTICLE_SPAWN_INTERVAL === 0 && !motorcycle.isJumping) {
        particles.push(new Particle(
            motorcycle.x + 10,
            groundY + 5,
            -2 - Math.random() * 2,
            -1 - Math.random() * 2,
            'rgb(194, 178, 128)',
            20
        ));
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        if (!particles[i].update()) {
            particles.splice(i, 1);
        }
    }
}

function drawParticles() {
    particles.forEach(p => p.draw());
}

// Key state
const keys = {};

// Utility functions
function getRandomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}

function calculateHitbox(spriteDims, sizeRatio = CONFIG.HITBOX_SIZE_RATIO, customOffsetX = null, customOffsetY = null) {
    const hitboxWidth = spriteDims.width * sizeRatio;
    const hitboxHeight = spriteDims.height * sizeRatio;
    return {
        width: hitboxWidth,
        height: hitboxHeight,
        offsetX: customOffsetX !== null ? customOffsetX : (spriteDims.width - hitboxWidth) / 2,
        offsetY: customOffsetY !== null ? customOffsetY : (spriteDims.height - hitboxHeight) / 2
    };
}

function checkAABBCollision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
}

// Cache hitbox dimensions
const normalDims = getSpriteDimensions(SPRITES.MOTORCYCLE_NORMAL);
const duckDims = getSpriteDimensions(SPRITES.MOTORCYCLE_DUCK);
const normalHitbox = calculateHitbox(normalDims, CONFIG.HITBOX_SIZE_RATIO, 1, 4);
const duckHitbox = calculateHitbox(duckDims, CONFIG.HITBOX_SIZE_RATIO, 1, 3);

function getMotorcycleHitbox() {
    const hitbox = motorcycle.isDucking ? duckHitbox : normalHitbox;
    
    return {
        x: motorcycle.x + hitbox.offsetX,
        y: motorcycle.y + hitbox.offsetY,
        width: hitbox.width,
        height: hitbox.height
    };
}

function calculateSpawnInterval(minInterval, maxInterval, minCap, minSpacing) {
    const speedFactor = Math.floor(frameCount / CONFIG.SPEED_INCREASE_INTERVAL);
    const adjustedMinInterval = Math.max(
        minCap,
        minInterval - speedFactor * CONFIG.OBSTACLE_INTERVAL_DECREASE_RATE
    );
    const adjustedMaxInterval = Math.max(
        adjustedMinInterval + minSpacing,
        maxInterval - speedFactor * CONFIG.OBSTACLE_INTERVAL_DECREASE_RATE
    );
    
    return Math.random() * (adjustedMaxInterval - adjustedMinInterval) + adjustedMinInterval;
}

function isObstacleTooClose(obstacleArray) {
    if (obstacleArray.length === 0) return false;
    const lastObstacle = obstacleArray[obstacleArray.length - 1];
    const lastObstacleEnd = lastObstacle.x + lastObstacle.width;
    
    // Check distance from last obstacle
    const obstacleDistance = canvas.width - lastObstacleEnd;
    if (obstacleDistance < CONFIG.SAFE_DISTANCE_BIRD_VEHICLE) return true;
    
    // Also check distance from last convoy if it extends further
    const convoyDistance = canvas.width - lastConvoyEndX;
    if (convoyDistance < CONFIG.SAFE_DISTANCE_BIRD_VEHICLE) return true;
    
    return false;
}

// CODE REVIEW: Game actions should be centralized functions (not duplicated in keyboard/touch)
function performJump() {
    if (!motorcycle.isJumping && !motorcycle.isDucking) {
        motorcycle.velocityY = motorcycle.jumpPower;
        motorcycle.isJumping = true;
        // Exit riding state when jumping
        if (motorcycle.isRidingVehicle) {
            motorcycle.isRidingVehicle = false;
            motorcycle.ridingVehicle = null;
        }
    }
}

// Event listeners
document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    
    if (gameState === GAME_STATES.WAITING && e.code === 'Space') {
        startGame();
    }
    
    if (gameState === GAME_STATES.PLAYING) {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
            performJump();
        }
    }
    
    // CODE REVIEW: Always preventDefault() for game input keys to avoid page scroll
    if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
        e.preventDefault();
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

// Touch/Mobile support
let isTouchDucking = false;

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    
    if (gameState === GAME_STATES.WAITING) {
        startGame();
        return;
    }
    
    if (gameState === GAME_STATES.PLAYING) {
        const touch = e.touches[0];
        const canvasRect = canvas.getBoundingClientRect();
        const touchYRelative = touch.clientY - canvasRect.top;
        const canvasHalfHeight = canvasRect.height / 2;
        
        // Touch bottom half to duck, top half to jump
        if (touchYRelative > canvasHalfHeight) {
            // Duck - hold finger down (works on ground or mid-air for fast-fall)
            isTouchDucking = true;
            keys['ArrowDown'] = true;
        } else {
            // Jump - tap top half (reuses keyboard jump logic)
            performJump();
        }
    }
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    // Release duck when finger is lifted
    if (isTouchDucking) {
        keys['ArrowDown'] = false;
        isTouchDucking = false;
    }
});

restartBtn.addEventListener('click', () => {
    gameOverlay.style.display = 'none';
    instructionsEl.style.display = 'block';
    startGame();
});

function startGame() {
    // CODE REVIEW: Ensure ALL game state variables are reset here
    // Check orientation on mobile before starting
    if (!checkOrientation()) {
        return; // Require landscape orientation on mobile devices
    }
    
    gameState = GAME_STATES.PLAYING;
    instructionsEl.style.display = 'none';
    
    // Dispatch custom event for embed wrapper to handle UI
    window.dispatchEvent(new CustomEvent('motorcyclegamestart'));
    
    score = 0;
    frameCount = 0;
    sunX = canvas.width - CONFIG.SUN_START_X;
    isNightMode = false;
    skyTransition = 0;
    stars = [];
    gameSpeed = CONFIG.INITIAL_SPEED;
    obstacles = [];
    flyingObstacles = [];
    billboards = [];
    particles = [];
    collisionFlash = 0;
    landingAnimation = 0;
    motorcycle.y = motorcycle.groundY;
    motorcycle.velocityY = 0;
    motorcycle.isJumping = false;
    motorcycle.isDucking = false;
    motorcycle.isRidingVehicle = false;
    motorcycle.ridingVehicle = null;
    
    // Reset spawn timers
    nextGroundObstacleFrame = CONFIG.OBSTACLE_MAX_INTERVAL;
    nextFlyingObstacleFrame = CONFIG.FLYING_OBSTACLE_MAX_INTERVAL + CONFIG.FLYING_OBSTACLE_MIN_SCORE;
    groundObstacleInterval = CONFIG.OBSTACLE_MAX_INTERVAL;
    flyingObstacleInterval = CONFIG.FLYING_OBSTACLE_MAX_INTERVAL;
    lastConvoyEndX = -1000;
    nextBillboardFrame = 900; // First billboard at 15 seconds
    
    gameOverlay.style.display = 'none';
    gameLoop();
}

// Spawn convoy vehicles behind a lead vehicle
function spawnConvoy(leadVehicle, minCount, maxCount) {
    const count = Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount;
    const smallVehicleTypes = obstacleTypes.filter(type => 
        type.sprite === 'CAR' || type.sprite === 'TRUCK' || type.sprite === 'VAN'
    );
    
    let lastVehicleEndX = leadVehicle.x + leadVehicle.width;
    
    for (let i = 0; i < count; i++) {
        const vehicleType = getRandomElement(smallVehicleTypes);
        const vehicleColors = getRandomVehicleColors();
        const vehiclePalette = createSpritePalette(vehicleColors);
        
        // Position vehicles behind the lead vehicle with proper spacing
        const spacing = 80 + (i * 100); // 80px after lead vehicle, then 100px between each
        const vehicleX = leadVehicle.x + leadVehicle.width + spacing;
        
        obstacles.push({
            x: vehicleX,
            y: groundY - vehicleType.height,
            width: vehicleType.width,
            height: vehicleType.height,
            sprite: vehicleType.sprite,
            type: vehicleType.type,
            rideable: vehicleType.rideable,
            flipH: false,
            palette: vehiclePalette
        });
        
        lastVehicleEndX = vehicleX + vehicleType.width;
    }
    
    // Track the end position of this convoy
    lastConvoyEndX = lastVehicleEndX;
}

function spawnObstacle() {
    // Spawn ground obstacle (vehicle) when it's time
    if (frameCount >= nextGroundObstacleFrame) {
        // Check if there's a recent flying obstacle that would create an impossible situation
        if (!isObstacleTooClose(flyingObstacles)) {
            // Separate rideable vs non-rideable vehicles based on score
            let availableTypes = obstacleTypes;
            if (score >= CONFIG.RIDEABLE_VEHICLE_MIN_SCORE) {
                // All vehicle types available
                availableTypes = obstacleTypes;
            } else {
                // Only non-rideable vehicles
                availableTypes = obstacleTypes.filter(type => !type.rideable);
            }
            
            const obstacleType = getRandomElement(availableTypes);
            const vehicleColors = getRandomVehicleColors();
            const vehiclePalette = createSpritePalette(vehicleColors);
            
            const newObstacle = {
                x: canvas.width,
                y: groundY - obstacleType.height,
                width: obstacleType.width,
                height: obstacleType.height,
                sprite: obstacleType.sprite,
                type: obstacleType.type,
                rideable: obstacleType.rideable,
                flipH: false, // Vehicles always face left (coming towards motorcycle)
                palette: vehiclePalette // Random vehicle color
            };
            
            obstacles.push(newObstacle);
            
            // Spawn convoy vehicles behind large vehicles based on playtime
            const playTimeSeconds = frameCount / 60; // Assuming 60 FPS
            
            // After 15 seconds: spawn 1-2 vehicles behind semi trucks
            // After 60 seconds: spawn up to 3 vehicles
            if (playTimeSeconds >= 15 && obstacleType.sprite === 'SEMI_TRUCK') {
                const maxConvoySize = playTimeSeconds >= 60 ? 3 : 2;
                spawnConvoy(newObstacle, 1, maxConvoySize);
            }
            
            // After 30 seconds: spawn 1-2 vehicles behind buses
            // After 60 seconds: spawn up to 3 vehicles
            if (playTimeSeconds >= 30 && obstacleType.sprite === 'BUS') {
                const maxConvoySize = playTimeSeconds >= 60 ? 3 : 2;
                spawnConvoy(newObstacle, 1, maxConvoySize);
            }
            
            // Calculate next spawn time with progressive difficulty
            groundObstacleInterval = calculateSpawnInterval(
                CONFIG.OBSTACLE_MIN_INTERVAL,
                CONFIG.OBSTACLE_MAX_INTERVAL,
                CONFIG.OBSTACLE_MIN_INTERVAL_CAP,
                CONFIG.GROUND_INTERVAL_MIN_SPACING
            );
            nextGroundObstacleFrame = frameCount + groundObstacleInterval;
        } else {
            // Retry soon if collision prevention blocked spawn
            nextGroundObstacleFrame = frameCount + CONFIG.OBSTACLE_RETRY_DELAY;
        }
    }
    
    // Spawn flying obstacles after minimum score threshold
    if (score > CONFIG.FLYING_OBSTACLE_MIN_SCORE && frameCount >= nextFlyingObstacleFrame) {
        // Check if there's a recent ground obstacle that would create an impossible situation
        if (!isObstacleTooClose(obstacles)) {
            const yOffset = getRandomElement(flyingObstacleConfig.heightVariations);
            flyingObstacles.push({
                x: canvas.width,
                y: groundY + yOffset,
                width: flyingObstacleConfig.width,
                height: flyingObstacleConfig.height,
                wingFrame: 0
            });
            
            // Calculate next spawn time with progressive difficulty
            flyingObstacleInterval = calculateSpawnInterval(
                CONFIG.FLYING_OBSTACLE_MIN_INTERVAL,
                CONFIG.FLYING_OBSTACLE_MAX_INTERVAL,
                CONFIG.FLYING_INTERVAL_MIN_CAP,
                CONFIG.FLYING_INTERVAL_MIN_SPACING
            );
            nextFlyingObstacleFrame = frameCount + flyingObstacleInterval;
        } else {
            // Retry soon if collision prevention blocked spawn
            nextFlyingObstacleFrame = frameCount + CONFIG.OBSTACLE_RETRY_DELAY;
        }
    }
    
    // Spawn billboards every 15 seconds (900 frames)
    if (frameCount >= nextBillboardFrame) {
        const billboardDims = getSpriteDimensions(SPRITES.BILLBOARD);
        const message = BILLBOARD_MESSAGES[Math.floor(Math.random() * BILLBOARD_MESSAGES.length)];
        
        billboards.push({
            x: canvas.width,
            y: groundY - billboardDims.height - 20, // 20px above ground
            width: billboardDims.width,
            height: billboardDims.height,
            message: message
        });
        
        nextBillboardFrame = frameCount + 900; // Next billboard in 15 seconds
    }
}

function updateObstacles() {
    // Update ground obstacles (vehicles)
    // Vehicles move slightly faster than road to appear traveling in opposite direction
    const vehicleSpeed = gameSpeed * 1.3;
    for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].x -= vehicleSpeed;
        
        // Remove off-screen obstacles and award points
        if (obstacles[i].x + obstacles[i].width < 0) {
            const points = obstacles[i].rideable ? CONFIG.RIDEABLE_VEHICLE_POINTS : CONFIG.VEHICLE_POINTS;
            obstacles.splice(i, 1);
            score += points;
        }
    }
    
    // Update flying obstacles
    for (let i = flyingObstacles.length - 1; i >= 0; i--) {
        flyingObstacles[i].x -= gameSpeed * CONFIG.FLYING_OBSTACLE_SPEED_MULTIPLIER;
        // Animate wing flapping
        flyingObstacles[i].wingFrame = Math.floor(frameCount / CONFIG.BIRD_WING_FLAP_FRAME_INTERVAL) % 2;
        
        // Remove off-screen obstacles
        if (flyingObstacles[i].x + flyingObstacles[i].width < 0) {
            flyingObstacles.splice(i, 1);
            score += CONFIG.FLYING_OBSTACLE_POINTS;
        }
    }
    
    // Update billboards (slower than road and vehicles)
    for (let i = billboards.length - 1; i >= 0; i--) {
        billboards[i].x -= gameSpeed * 0.7; // Slower than road and vehicles
        
        // Remove off-screen billboards
        if (billboards[i].x + billboards[i].width < 0) {
            billboards.splice(i, 1);
        }
    }
}

function updateMotorcycle() {
    // Handle riding state
    if (motorcycle.isRidingVehicle && motorcycle.ridingVehicle) {
        const vehicle = motorcycle.ridingVehicle;
        
        // Check if vehicle scrolled past motorcycle
        if (vehicle.x + vehicle.width < motorcycle.x) {
            // Fall off vehicle
            motorcycle.isRidingVehicle = false;
            motorcycle.ridingVehicle = null;
            motorcycle.isJumping = true;
            motorcycle.velocityY = 0; // Start falling from current position
        } else {
            // Lock motorcycle Y position to top of vehicle
            const rideHeight = 1; // Minimal offset above vehicle
            const currentHeight = motorcycle.isDucking ? motorcycle.duckHeight : motorcycle.normalHeight;
            motorcycle.y = vehicle.y - currentHeight - rideHeight;
            
            // Player can jump while riding
            // (handled by handleJump function)
        }
    }
    
    // Handle ducking (only when not riding)
    if (!motorcycle.isRidingVehicle && keys['ArrowDown'] && !motorcycle.isJumping) {
        motorcycle.isDucking = true;
        motorcycle.y = motorcycle.groundY + (motorcycle.normalHeight - motorcycle.duckHeight);
    } else if (!motorcycle.isJumping && !motorcycle.isRidingVehicle) {
        motorcycle.isDucking = false;
        motorcycle.y = motorcycle.groundY;
    }
    
    // Apply gravity
    if (motorcycle.isJumping) {
        // Apply extra gravity for fast-fall when ducking mid-air
        const gravityMultiplier = keys['ArrowDown'] ? CONFIG.FAST_FALL_GRAVITY : motorcycle.gravity;
        motorcycle.velocityY += gravityMultiplier;
        motorcycle.y += motorcycle.velocityY;
        
        // Land on ground
        if (motorcycle.y >= motorcycle.groundY) {
            motorcycle.y = motorcycle.groundY;
            motorcycle.velocityY = 0;
            motorcycle.isJumping = false;
            motorcycle.isRidingVehicle = false;
            motorcycle.ridingVehicle = null;
            landingAnimation = 8; // Show landing animation for 8 frames
        }
    }
    
    // Decrement landing animation counter
    if (landingAnimation > 0) {
        landingAnimation--;
    }
}

function checkCollisions() {
    const motorHitbox = getMotorcycleHitbox();
    
    // Check ground obstacles (vehicles)
    for (let obstacle of obstacles) {
        // Two-phase collision detection for rideable vehicles
        if (obstacle.rideable) {
            // Phase 1: Check if landing on top of rideable vehicle
            const landingOnTop = 
                motorcycle.isJumping && 
                motorcycle.velocityY > 0 && // falling down
                motorHitbox.x + motorHitbox.width > obstacle.x && 
                motorHitbox.x < obstacle.x + obstacle.width &&
                motorHitbox.y + motorHitbox.height <= obstacle.y + 10 && // within 10px of top
                motorHitbox.y + motorHitbox.height >= obstacle.y - 5; // above or slightly overlapping
            
            if (landingOnTop) {
                // Land on vehicle
                motorcycle.isRidingVehicle = true;
                motorcycle.ridingVehicle = obstacle;
                motorcycle.isJumping = false;
                motorcycle.velocityY = 0;
                continue; // Skip collision check
            }
        }
        
        // Phase 2: Standard AABB collision for side/front impacts
        if (!motorcycle.isRidingVehicle && checkAABBCollision(motorHitbox, obstacle)) {
            gameOver();
            return;
        }
    }
    
    // Check flying obstacles
    for (let obstacle of flyingObstacles) {
        if (checkAABBCollision(motorHitbox, obstacle)) {
            gameOver();
            return;
        }
    }
}

function gameOver() {
    gameState = GAME_STATES.GAME_OVER;
    collisionFlash = CONFIG.COLLISION_FLASH_DURATION;
    
    // Update high scores
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('motorcycleHighScore', highScore);
    }
    
    if (score > dailyHighScore) {
        dailyHighScore = score;
        localStorage.setItem('motorcycleDailyHighScore', dailyHighScore);
    }
    
    if (score > allTimeHighScore) {
        allTimeHighScore = score;
        localStorage.setItem('motorcycleAllTimeHighScore', allTimeHighScore);
    }
    
    finalScoreEl.textContent = `Score: ${score}`;
    dailyHighScoreEl.textContent = `Best Today: ${dailyHighScore}`;
    allTimeHighScoreEl.textContent = `Best Ever: ${allTimeHighScore}`;
    gameOverlay.style.display = 'block';
    
    // Dispatch custom event for embed wrapper to handle UI
    window.dispatchEvent(new CustomEvent('motorcyclegameover'));
}

function drawMotorcycle() {
    // Show landing animation (duck sprite for 5 frames), otherwise show normal state
    const sprite = (motorcycle.isDucking || landingAnimation > 0) 
        ? SPRITES.MOTORCYCLE_DUCK 
        : SPRITES.MOTORCYCLE_NORMAL;
    
    // Adjust y position to align bottom of sprites
    let drawY = motorcycle.y;
    if (landingAnimation > 0 && !motorcycle.isDucking) {
        // MOTORCYCLE_DUCK is shorter, so offset it down to align the bottom
        const normalHeight = getSpriteDimensions(SPRITES.MOTORCYCLE_NORMAL).height;
        const duckHeight = getSpriteDimensions(SPRITES.MOTORCYCLE_DUCK).height;
        drawY += (normalHeight - duckHeight);
    }
    
    // Flash effect on collision
    if (collisionFlash > 0) {
        if (collisionFlash % 2 === 0) {
            ctx.globalAlpha = 0.3;
        }
        collisionFlash--;
    }
    
    drawSprite(sprite, motorcycle.x, drawY);
    ctx.globalAlpha = 1.0;
}

function drawObstacles() {
    // Draw ground obstacles (vehicle sprites)
    obstacles.forEach(obstacle => {
        const sprite = SPRITES[obstacle.sprite];
        if (sprite) {
            drawSprite(sprite, obstacle.x, obstacle.y, CONFIG.SPRITE_SCALE, obstacle.flipH, obstacle.palette);
        }
    });
    
    // Draw flying obstacles (birds with wing animation)
    flyingObstacles.forEach(obstacle => {
        const sprite = obstacle.wingFrame === 0 ? SPRITES.BIRD_UP : SPRITES.BIRD_DOWN;
        drawSprite(sprite, obstacle.x, obstacle.y);
    });
}

function drawBillboards() {
    billboards.forEach(billboard => {
        // Draw billboard sprite
        drawSprite(SPRITES.BILLBOARD, billboard.x, billboard.y);
        
        // Draw white background for text area to make it readable at night
        ctx.fillStyle = '#f5f5f5';
        const padding = 6; // Border width in pixels (scaled)
        ctx.fillRect(
            billboard.x + padding, 
            billboard.y + padding, 
            billboard.width - (padding * 2), 
            billboard.height - (padding * 2) - 30 // Exclude post area (10 pixels * 3 scale)
        );
        
        // Draw text on billboard
        ctx.fillStyle = '#2d2d2d';
        ctx.font = 'bold 23px Courier New';
        ctx.textAlign = 'center';
        
        const centerX = billboard.x + (billboard.width / 2);
        const centerY = billboard.y + (billboard.height / 2);
        
        if (billboard.message.length === 1) {
            // Single line - center vertically
            ctx.fillText(billboard.message[0], centerX, centerY);
        } else if (billboard.message.length === 2) {
            // Two lines - centered vertically
            ctx.fillText(billboard.message[0], centerX, centerY - 12);
            ctx.fillText(billboard.message[1], centerX, centerY + 12);
        } else if (billboard.message.length === 3) {
            // Three lines - evenly spaced
            ctx.fillText(billboard.message[0], centerX, centerY - 18);
            ctx.fillText(billboard.message[1], centerX, centerY);
            ctx.fillText(billboard.message[2], centerX, centerY + 18);
        }
    });
}

function drawSkyObject() {
    const skyY = CONFIG.SUN_Y_POSITION;
    const radius = CONFIG.SUN_RADIUS;
    
    if (isNightMode) {
        // Draw crescent moon
        ctx.fillStyle = SKY_COLORS.MOON;
        ctx.beginPath();
        ctx.arc(sunX, skyY, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw shadow to create crescent
        ctx.fillStyle = interpolateColor(SKY_COLORS.DAY, SKY_COLORS.NIGHT, skyTransition);
        ctx.beginPath();
        ctx.arc(sunX + CONFIG.MOON_CRESCENT_OFFSET, skyY, radius, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Draw sun with glow
        const gradient = ctx.createRadialGradient(sunX, skyY, radius * 0.3, sunX, skyY, radius * 2);
        gradient.addColorStop(0, SKY_COLORS.SUN_GLOW[0]);
        gradient.addColorStop(0.3, SKY_COLORS.SUN_GLOW[1]);
        gradient.addColorStop(0.6, SKY_COLORS.SUN_GLOW[2]);
        gradient.addColorStop(1, SKY_COLORS.SUN_GLOW[3]);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(sunX, skyY, radius * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw sun core
        ctx.fillStyle = SKY_COLORS.SUN_CORE;
        ctx.beginPath();
        ctx.arc(sunX, skyY, radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawStars() {
    if (!isNightMode) return;
    
    stars.forEach(star => {
        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
    });
}

function updateStars() {
    if (!isNightMode) return;
    
    // Move stars left at their individual speeds
    stars.forEach(star => {
        star.x -= star.speed;
        
        // Wrap around when they go off screen
        if (star.x < -10) {
            star.x = canvas.width + 10;
        }
    });
}

function updateDayNightCycle() {
    // Move sun/moon across sky
    sunX -= CONFIG.SUN_MOON_SPEED;
    
    // Switch between day and night when sun/moon reaches left side
    if (sunX <= CONFIG.SUN_START_X) {
        isNightMode = !isNightMode;
        if (isNightMode) {
            initializeStars();
        }
        sunX = canvas.width - CONFIG.SUN_START_X;
    }
    
    // Gradually transition sky color (crossfade)
    const targetTransition = isNightMode ? 1 : 0;
    if (skyTransition < targetTransition) {
        skyTransition = Math.min(skyTransition + CONFIG.SKY_TRANSITION_SPEED, targetTransition);
    } else if (skyTransition > targetTransition) {
        skyTransition = Math.max(skyTransition - CONFIG.SKY_TRANSITION_SPEED, targetTransition);
    }
    
    // Update stars during night
    updateStars();
}

function initializeStars() {
    stars = [];
    for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * (groundY - 100),
            size: Math.random() * (CONFIG.STAR_MAX_SIZE - CONFIG.STAR_MIN_SIZE) + CONFIG.STAR_MIN_SIZE,
            speed: Math.random() * (CONFIG.STAR_MAX_SPEED - CONFIG.STAR_MIN_SPEED) + CONFIG.STAR_MIN_SPEED,
            opacity: Math.random() * (CONFIG.STAR_MAX_OPACITY - CONFIG.STAR_MIN_OPACITY) + CONFIG.STAR_MIN_OPACITY
        });
    }
}

function drawGround() {
    // Draw road (wider black line)
    ctx.strokeStyle = COLORS.GROUND_LINE;
    ctx.lineWidth = CONFIG.GROUND_ROAD_WIDTH;
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(canvas.width, groundY);
    ctx.stroke();
    
    // Draw center lane divider (white dashed line) - batched
    ctx.strokeStyle = COLORS.CENTER_LINE;
    ctx.lineWidth = CONFIG.CENTER_LINE_WIDTH;
    ctx.beginPath();
    const offset = (frameCount * gameSpeed) % CONFIG.GROUND_DASH_SPACING;
    for (let i = -offset; i < canvas.width; i += CONFIG.GROUND_DASH_SPACING) {
        ctx.moveTo(i, groundY);
        ctx.lineTo(i + CONFIG.GROUND_DASH_LENGTH, groundY);
    }
    ctx.stroke();
}

function drawScore() {
    // Interpolate text color between dark and white based on sky transition
    ctx.fillStyle = interpolateColor(SKY_COLORS.TEXT_DAY, SKY_COLORS.TEXT_NIGHT, skyTransition);
    
    // Main score - larger font, bold
    ctx.font = 'bold 18px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`Score: ${score}`, canvas.width / 2, 30);
    
    // Daily/all-time scores - 2/3 the size (12px), not bold
    ctx.font = '12px Courier New';
    ctx.fillText(`Best Today: ${dailyHighScore}`, canvas.width / 2, 46);
    ctx.fillText(`Best Ever: ${allTimeHighScore}`, canvas.width / 2, 62);
    
    // Debug mode - show FPS and speed
    if (CONFIG.DEBUG_MODE) {
        ctx.font = 'bold 18px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`Speed: ${gameSpeed.toFixed(1)}`, 20, 30);
    }
}

function drawVersion() {
    ctx.fillStyle = interpolateColor(SKY_COLORS.TEXT_DAY, SKY_COLORS.TEXT_NIGHT, skyTransition);
    ctx.font = '14px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText(VERSION, canvas.width - 10, canvas.height - 10);
}

function drawDebugHitboxes() {
    if (!CONFIG.DEBUG_MODE) return;
    
    // Draw motorcycle hitbox
    const motorHitbox = getMotorcycleHitbox();
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.lineWidth = 2;
    ctx.strokeRect(motorHitbox.x, motorHitbox.y, motorHitbox.width, motorHitbox.height);
    
    // Draw obstacle hitboxes
    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
    obstacles.forEach(obstacle => {
        ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });
    
    flyingObstacles.forEach(obstacle => {
        ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });
}

function drawWaitingScreen() {
    ctx.fillStyle = COLORS.TEXT;
    ctx.font = 'bold 32px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('Press SPACE to Start', canvas.width / 2, canvas.height / 2 - 50);
    
    // Draw version number in small font
    ctx.font = '12px Courier New';
    ctx.fillText(VERSION, canvas.width / 2, canvas.height / 2 - 10);
    
    // Draw in correct order: ground first, then motorcycle on top
    drawGround();
    drawMotorcycle();
}

function draw() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw sky background with crossfade
    ctx.fillStyle = interpolateColor(SKY_COLORS.DAY, SKY_COLORS.NIGHT, skyTransition);
    ctx.fillRect(0, 0, canvas.width, groundY);
    
    if (gameState === GAME_STATES.WAITING) {
        drawWaitingScreen();
        return;
    }
    
    // CODE REVIEW: Draw order must be back-to-front (stars â†’ sky â†’ billboards â†’ ground â†’ particles â†’ player â†’ obstacles â†’ UI)
    drawStars();
    drawSkyObject();
    drawBillboards(); // Draw billboards before ground so they appear in background
    drawGround();
    drawParticles();
    drawMotorcycle();
    drawObstacles();
    drawScore();
    drawVersion();
    drawDebugHitboxes();
}

function update() {
    if (gameState !== GAME_STATES.PLAYING) return;
    
    frameCount++;
    
    // Update day/night cycle
    updateDayNightCycle();
    
    // Award 1 point for survival
    if (frameCount % CONFIG.SURVIVAL_POINTS_INTERVAL === 0) {
        score++;
    }
    
    // Increase difficulty over time
    // After 30 seconds (1800 frames), slow speed increases by half
    if (frameCount % CONFIG.SPEED_INCREASE_INTERVAL === 0) {
        const playTimeSeconds = frameCount / 60;
        const speedIncrement = playTimeSeconds >= 30 ? CONFIG.SPEED_INCREMENT * 0.5 : CONFIG.SPEED_INCREMENT;
        gameSpeed += speedIncrement;
    }
    
    updateMotorcycle();
    updateObstacles();
    spawnObstacle();
    spawnDustParticle();
    updateParticles();
    checkCollisions();
}

// Orientation detection for mobile devices
function isLandscape() {
    // Check if it's a mobile device first
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (!isMobile) {
        return true; // Allow desktop play in any orientation
    }
    
    // For mobile, check orientation
    if (screen.orientation && screen.orientation.type) {
        return screen.orientation.type.includes('landscape');
    } else if (window.orientation !== undefined) {
        // Fallback for older browsers: 90 or -90 is landscape
        return Math.abs(window.orientation) === 90;
    } else {
        // Final fallback: check aspect ratio
        return window.innerWidth > window.innerHeight;
    }
}

function checkOrientation() {
    if (isLandscape()) {
        orientationOverlay.style.display = 'none';
        return true;
    } else {
        orientationOverlay.style.display = 'block';
        // Pause the game if it was playing (orientation changed mid-game)
        if (gameState === GAME_STATES.PLAYING) {
            gameState = GAME_STATES.WAITING;
        }
        return false;
    }
}

function gameLoop() {
    update();
    draw();
    
    if (gameState === GAME_STATES.PLAYING) {
        requestAnimationFrame(gameLoop);
    }
}

// Initial draw
draw();

// Check orientation on load and listen for changes
checkOrientation();
window.addEventListener('orientationchange', checkOrientation);
window.addEventListener('resize', checkOrientation);

        })();
    }
    
    // Public API
    window.MotorcycleRunner = {
        show: showGame,
        hide: hideGame,
        version: '0.12'
    };
    
    console.log('Motorcycle Runner loaded. Press SPACEBAR to play!');
})();
